---
title: "clinical_CTD.LT.XL"
author: "LT & XL"
date: "1/19/2022"
output: 
  html_document:
  code_folding: hide
toc: true
toc_depth: 2
editor_options: 
  chunk_output_type: console
---
## Get number of metabolties detected
``` {r counts}
require(openxlsx)
data_mx=read.xlsx("dataset1.xlsx",sheet=2)
#load("clinical_data_July2020.RData")

data_mx_unnamed = data_mx[grep("x -", rownames(data_mx)),
                          which(colnames(data_mx) %in% c(unlist(cohorts)))]
zscore_cts = apply(data_mx_unnamed, 2, function(i) length(which(!is.na(i))))
mean(zscore_cts)
min(zscore_cts)
max(zscore_cts)


data_mx_named = data_mx[-grep("x -", rownames(data_mx)),
                        which(colnames(data_mx) %in% c(unlist(cohorts)))]
zscore_cts = apply(data_mx_named, 2, function(i) length(which(!is.na(i))))
mean(zscore_cts)
min(zscore_cts)
max(zscore_cts)
```


## Building a Gaussian Graphical Model to Diagnose 7 Different Metabolic Disorders
Metabolites represented in at least 50% of reference and 50% of disease cases were included in network learning.
``` {r learn-nets_heparin}
require(CTD)
require(huge)
data("Miller2015")
data_mx = Miller2015[,grep("IEM_", colnames(Miller2015))]
ind = grep("x - ", rownames(data_mx))
data_mx = data_mx[-ind,]
refs = data_mx[,which(diagnoses$diagnosis=="No biochemical genetic diagnosis")]
ref_fill = (Miller2015$`Times identifed in all 200 samples`)/200
ref_fill = ref_fill[-ind]
refs2 = refs[which(ref_fill>0.8),]
cohorts = lapply(cohorts, function(i) i[which(i %in% colnames(Miller2015))])
for (model in c("cit", "msud", "mma", "pa", "pku", "cob", "ga", "gamt")) {
  for (fold in 1:length(cohorts[[model]])) {
    print(sprintf("Learning graphs for diag %s, fold %d...", model, fold))
    diag_pts = cohorts[[model]][-fold]
    print(diag_pts)
    fill.rate = apply(data_mx[,which(colnames(data_mx) %in% diag_pts)], 1, function(i) sum(is.na(i))/length(i))
    diag_data = data_mx[intersect(which(ref_fill>0.8), which(fill.rate<=0.20)), which(colnames(data_mx) %in% diag_pts)]
    diag_data = diag_data[which(rownames(diag_data) %in% rownames(refs2)),]
    print("Individual samples as training data. Latent variable embedding and network pruning.")
    diag_data = data.surrogateProfiles(data = diag_data, std = 1, useMnDiseaseProfile = FALSE, addHealthyControls = TRUE, ref_data = refs2)
    print(dim(diag_data))
    
    # Disease Network: GLASSO approach
    inv_covmatt = huge(t(diag_data), method="glasso")
    inv_covmatt_select = huge.select(inv_covmatt, criterion = "stars")
    inv_covmat = as.matrix(inv_covmatt_select$icov[[which(inv_covmatt_select$lambda==inv_covmatt_select$opt.lambda)]])
    diag(inv_covmat) = 0;
    colnames(inv_covmat) = rownames(diag_data)
    ig = graph.adjacency(as.matrix(inv_covmat), mode="undirected", weighted=TRUE, add.colnames='name')
    V(ig)$name = rownames(diag_data)
    print(ig)
    
    # Reference Network: GLASSO approach
    ref_data = data.surrogateProfiles(data = refs2, std = 1, useMnDiseaseProfile = FALSE, addHealthyControls = TRUE, ref_data = refs2)
    ref_data = ref_data[,-which(duplicated(colnames(ref_data)))]
    print(dim(ref_data))
    inv_covmatt = huge(t(ref_data), method="glasso", lambda = inv_covmatt_select$opt.lambda)
    inv_covmat = as.matrix(inv_covmatt$icov[[1]])
    diag(inv_covmat) = 0;
    colnames(inv_covmat) = rownames(ref_data)
    ig_ref = graph.adjacency(as.matrix(inv_covmat), mode="undirected", weighted=TRUE, add.colnames='name')
    V(ig_ref)$name = rownames(ref_data)
    print(ig_ref)
    
    ig_pruned = graph.naivePruning(ig, ig_ref)
    print(ig_pruned)
    save(ig, ig_ref, ig_pruned, file=sprintf("graphs/bg_%s_fold%d.RData", model, fold))
    rm(ig, ig_pruned)
  }
}


```

``` {r learn-networks_edta}
rm(list=ls())
require(CTD)
require(huge)
setwd("Clinical_paper")
load("clinical_data_Oct2020.RData")
data_mx["argininosuccinate", which(is.na(data_mx["argininosuccinate",]))] = 0
refs = data_mx[, which(colnames(data_mx) %in% cohorts$edta_refs)]
ref_fill = apply(refs, 1, function(i) sum(is.na(i))/length(i))
for (model in c("asld")) { #  "aadc", "abat", "adsl", "arg", "asld", "otc", "zsd", "rcdp"
  for (fold in 1:length(cohorts[[model]])) {
    print(sprintf("Learning graphs for diag %s, fold %d...", model, fold))
    diag_pts = cohorts[[model]][-fold]
    print(diag_pts)
    fill.rate = apply(data_mx[,which(colnames(data_mx) %in% diag_pts)], 1, function(i) sum(is.na(i))/length(i))
    diag_data = data_mx[intersect(which(ref_fill<0.5), which(fill.rate<0.5)), which(colnames(data_mx) %in% diag_pts)]
    print(nrow(diag_data))
    print(diag_data["argininosuccinate",])
    print("Individual samples as training data. Latent variable embedding and network pruning.")
    refs2 = refs[which(rownames(refs) %in% rownames(diag_data)), ]
    diag_data = data.surrogateProfiles(data = diag_data, std = 1, ref_data = refs2)
    print(dim(diag_data))
    
    # Disease Network: GLASSO approach
    inv_covmatt = huge(t(diag_data), method="glasso")
    inv_covmatt_select = huge.select(inv_covmatt, criterion = "stars")
    inv_covmat = as.matrix(inv_covmatt_select$icov[[which(inv_covmatt_select$lambda==inv_covmatt_select$opt.lambda)]])
    diag(inv_covmat) = 0;
    colnames(inv_covmat) = rownames(diag_data)
    ig = graph.adjacency(as.matrix(inv_covmat), mode="undirected", weighted=TRUE, add.colnames='name')
    V(ig)$name = rownames(diag_data)
    print(ig)
    
    # Reference Network: GLASSO approach
    ref_data = data.surrogateProfiles(data = refs2, std = 1, ref_data = refs2)
    ref_data = ref_data[,-which(duplicated(colnames(ref_data)))]
    print(dim(ref_data))
    inv_covmatt = huge(t(ref_data), method="glasso", lambda = inv_covmatt_select$opt.lambda)
    inv_covmat = as.matrix(inv_covmatt$icov[[1]])
    diag(inv_covmat) = 0;
    colnames(inv_covmat) = rownames(ref_data)
    ig_ref = graph.adjacency(as.matrix(inv_covmat), mode="undirected", weighted=TRUE, add.colnames='name')
    V(ig_ref)$name = rownames(ref_data)
    print(ig_ref)
  
    ig_pruned = graph.naivePruning(ig, ig_ref)
    print(ig_pruned)
    print(degree(ig_pruned, "argininosuccinate"))
    save(ig, ig_ref, ig_pruned, file=sprintf("graphs_GMpaper/bg_%s_fold%d.RData", model, fold))
    rm(ig, ig_ref, ig_pruned)
  }
}


# Network descriptive statistics
for (model in c("arg", "asld", "cit", "otc", "rcdp", "zsd", "abat", "aadc", "adsl", "mma", "msud", "pa", "pku", "cob", "ga", "gamt")) {
  print(model)
  for (fold in 1:length(cohorts[[model]])) {
    print(fold)
    load(sprintf("Clinical_paper/graphs/bg_%s_fold%d.RData", model, fold))
    print(sprintf("Disease-Control Network: %d-%d", length(V(ig)$name), length(E(ig)$weight)))
    print(sprintf("Control-only Network: %d-%d", length(V(ig_ref)$name), length(E(ig_ref)$weight)))
    print(sprintf("Disease-Specific Network: %d-%d", length(V(ig_pruned)$name), length(E(ig_pruned)$weight)))
  }
}
```

## Get the main disease module for each disease-specific network model.
```{r getDisMod}
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Clinical_paper/")
rm(list=ls())
require(R.utils)
require(CTD)
load("clinical_data_Oct2020.RData")
which(apply(data_mx, 2, function(i) sum(na.omit(i)==0)/length(na.omit(i)))==1)
table(data_mx["argininosuccinate",])
p0=0.1
p1=0.9
thresholdDiff=0.01
# Add CTDsim distance from "downtown module" as second quantitative variable
disFromDowntown = function(dis_mod, ptBSbyK.dis, p2.sig.nodes, p2.optBS, ranks, G) {
  p1.e = mle.getEncodingLength(ptBSbyK.dis, NULL, ptID, G)[,"IS.alt"]
  p2.e = mle.getEncodingLength(p2.optBS, NULL, ptID2, G)[,"IS.alt"]

  # Using predefined node ranks, get optimal bitstring for encoding of patient1's union patient2's subsets.
  p12.sig.nodes = unique(c(dis_mod, p2.sig.nodes))
  p12.e = c()
  for (k in 1:length(ptBSbyK.dis)) {
    dis_mod_cpy = dis_mod
    p2.sig.nodes_cpy = p2.sig.nodes
    
    dis_mod_k = names(which(ptBSbyK.dis[[k]]==1))
    p2.sig.nodes_k = names(which(p2.optBS[[k]]==1))
    while (length(dis_mod_k)<k) {
      dis_mod_k = unique(c(dis_mod_k, dis_mod_cpy[1]))
      dis_mod_cpy = dis_mod_cpy[-1]
    }
    while (length(p2.sig.nodes_k)<k) {
      p2.sig.nodes_k = unique(c(p2.sig.nodes_k, p2.sig.nodes_cpy[1]))
      p2.sig.nodes_cpy = p2.sig.nodes_cpy[-1]
    }
    p12.sig.nodes_k = sapply(unique(c(dis_mod_k, p2.sig.nodes_k)), trimws)
    p12.optBS = mle.getPtBSbyK(p12.sig.nodes_k, ranks)
    res = mle.getEncodingLength(p12.optBS, NULL, NULL, G)
    p12.e[k] = res[which.max(res[,"d.score"]), "IS.alt"] + log2(choose(length(G), 1))*(length(p12.sig.nodes_k)-which.max(res[,"d.score"]))
  }
  return (list(p1.e=p1.e, p2.e=p2.e, p12.e=p12.e,
               NCD=(p12.e-apply(cbind(p1.e, p2.e), 1, min))/apply(cbind(p1.e, p2.e), 1, max)))
}

# Get downtown disease modules for all modelled disease states
disMod = list()
for (model in c("aadc", "abat", "adsl", "arg", "asld", "cit", "otc", "cob", "ga", "gamt", "msud", "mma", "pa", "zsd", "rcdp", "pku")) { # 
  print(sprintf("%s...", toupper(model)))
  load("clinical_data_Oct2020.RData")
  mn = apply(data_mx[,which(colnames(data_mx) %in% cohorts[[model]])], 1, function(i) mean(na.omit(i)))
  mn = mn[-which(is.na(mn))]
  downtown_disease_module = c()
  for (pt in 1:length(cohorts[[model]])) {
    ig = loadToEnv(sprintf("graphs_GMpaper/bg_%s_fold%d.RData", model, pt))[["ig_pruned"]]
    ranks = loadToEnv(sprintf("ranks_GMpaper/%s%d-ranks.RData", model, pt))[["permutationByStartNode"]]
    ranks = lapply(ranks, tolower)
    adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
    G = vector(mode="list", length=length(V(ig)$name))
    names(G) = V(ig)$name
    S = mn[which(abs(mn)>2)]
    S = S[which(names(S) %in% names(G))]
    it=0
    while (length(S)<15) {
      S = mn[which(abs(mn)>(2-0.1*it))]
      S = S[which(names(S) %in% names(G))]
      it = it + 1
    }
    ptBSbyK = mle.getPtBSbyK(names(S), ranks)
    res = mle.getEncodingLength(ptBSbyK, NULL, NULL, G)
    downtown_disease_module = c(downtown_disease_module, names(which(ptBSbyK[[which.max(res[,"d.score"])]]==1)))
  }
  print(model)
  length(unique(downtown_disease_module))
  
  # Estimate disease module "purity" based on 2 size thresholds and known case mean distances
  fold=1
  ig = loadToEnv(sprintf("graphs_GMpaper/bg_%s_fold%d.RData", model, fold))[["ig_pruned"]]
  ranks = loadToEnv(sprintf("ranks_GMpaper/%s%d-ranks.RData", model, fold))[["permutationByStartNode"]]
  ranks = lapply(ranks, tolower)
  adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
  G = vector(mode="list", length=length(V(ig)$name))
  names(G) = V(ig)$name
  data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
  data_mx = data_mx[,which(colnames(data_mx) %in% cohorts[[model]])]
  purity_mets = list()
  purity = c()
  # Size1: Full downtown disease module
  tmp.mm = unique(downtown_disease_module)
  tmp.mm = tmp.mm[which(tmp.mm %in% names(G))]
  ptBSbyK.dis = mle.getPtBSbyK(tmp.mm, ranks)
  res = mle.getEncodingLength(ptBSbyK.dis, NULL, ptID, G)
  downtown_disease_mod = names(which(ptBSbyK.dis[[which.max(res[,"d.score"])]]==1))
  print(length(unique(downtown_disease_mod)))
  dd = c()
  for (pt in 1:length(cohorts[[model]])) {
    ptBSbyK.dis = mle.getPtBSbyK(unique(downtown_disease_mod), ranks)
    p2.sig.nodes = names(data_mx[order(abs(data_mx[,pt]), decreasing = TRUE), pt][1:length(unique(downtown_disease_mod))])
    p2.optBS = mle.getPtBSbyK(p2.sig.nodes, ranks)
    ctdsim = disFromDowntown(unique(downtown_disease_mod), ptBSbyK.dis, p2.sig.nodes, p2.optBS, ranks, G)
    dd[pt] = min(ctdsim$NCD)
  }
  purity_mets[[1]] = unique(downtown_disease_module)
  purity[1] = mean(dd)
  # Size2: Smaller disease module
  downtown_disease_module = names(which(table(downtown_disease_module)>(length(cohorts[[model]])/2)))
  tmp.mm = unique(downtown_disease_module)
  tmp.mm = tmp.mm[which(tmp.mm %in% names(G))]
  ptBSbyK.dis = mle.getPtBSbyK(unique(downtown_disease_module), ranks)
  res = mle.getEncodingLength(ptBSbyK.dis, NULL, ptID, G)
  downtown_disease_mod = names(which(ptBSbyK.dis[[which.max(res[,"d.score"])]]==1))
  print(length(unique(downtown_disease_mod)))
  dd = c()
  for (pt in 1:length(cohorts[[model]])) {
    ptBSbyK.dis = mle.getPtBSbyK(unique(downtown_disease_mod), ranks)
    p2.sig.nodes = names(data_mx[order(abs(data_mx[,pt]), decreasing = TRUE), pt][1:length(unique(downtown_disease_mod))])
    p2.optBS = mle.getPtBSbyK(p2.sig.nodes, ranks)
    ctdsim = disFromDowntown(unique(downtown_disease_mod), ptBSbyK.dis, p2.sig.nodes, p2.optBS, ranks, G)
    dd[pt] = min(ctdsim$NCD)
  }
  purity_mets[[2]] = downtown_disease_module
  purity[2] = mean(dd)
  
  # Selected disease module based on "purity" estimates
  downtown_disease_module = purity_mets[[which.min(purity)]]
  
  disMod[[model]] = downtown_disease_module
}
lapply(disMod, length)
save(disMod, file="/Users/lillian.rosa/Downloads/CTDext/inst/shiny-app/disMod_Oct2020.RData")

```

## Run CTD on Metabolomics Profiles to Interpret Perturbation Patterns in Disease Context
``` {r runCTD}
# Note: Do not include Alaimo patients in this result - must have known diagnosis from one of the 16 disease network models,
#       or be a healthy control (heparin or EDTA).
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Clinical_paper/")
rm(list=ls())
require(R.utils)
require(CTD)
load("/Users/lillian.rosa/Downloads/CTDext/inst/shiny-app/disMod_Oct2020.RData")
p0=0.1
p1=0.9
thresholdDiff=0.01
kmx=30
# Add CTDsim distance from "downtown module" as second quantitative variable
disFromDowntown = function(dis_mod, ptBSbyK.dis, p2.sig.nodes, p2.optBS, ranks, G, mn_prof, p2_prof) {
  p1.e = mle.getEncodingLength(ptBSbyK.dis, NULL, ptID, G)[,"IS.alt"]
  p2.e = mle.getEncodingLength(p2.optBS, NULL, ptID2, G)[,"IS.alt"]

  dirSim = vector("numeric", length = length(ptBSbyK.dis))
  for (k in 1:length(ptBSbyK.dis)) {
    p1.sn = dis_mod[1:k]
    p2.sn = p2.sig.nodes[1:k]
    p1.dirs = mn_prof[p1.sn]
    p1.dirs[which(!(p1.dirs > 0))] = 0
    p1.dirs[which(p1.dirs > 0)] = 1
    p2.dirs = p2_prof[p2.sn]
    p2.dirs[which(!(p2.dirs > 0))] = 0
    p2.dirs[which(p2.dirs > 0)] = 1
    p1.snn = sprintf("%s%d", p1.sn, p1.dirs)
    p2.snn = sprintf("%s%d", p2.sn, p2.dirs)
    dirSim[k] = 1 - (length(intersect(p1.snn, p2.snn))/length(union(p1.snn, p2.snn)))
  }
  # Using predefined node ranks, get optimal bitstring for encoding of patient1's union patient2's subsets.
  p12.sig.nodes = unique(c(dis_mod, p2.sig.nodes))
  p12.e = c()
  for (k in 1:length(ptBSbyK.dis)) {
    dis_mod_cpy = dis_mod
    p2.sig.nodes_cpy = p2.sig.nodes
    
    dis_mod_k = names(which(ptBSbyK.dis[[k]]==1))
    p2.sig.nodes_k = names(which(p2.optBS[[k]]==1))
    while (length(dis_mod_k)<k) {
      dis_mod_k = unique(c(dis_mod_k, dis_mod_cpy[1]))
      dis_mod_cpy = dis_mod_cpy[-1]
    }
    while (length(p2.sig.nodes_k)<k) {
      p2.sig.nodes_k = unique(c(p2.sig.nodes_k, p2.sig.nodes_cpy[1]))
      p2.sig.nodes_cpy = p2.sig.nodes_cpy[-1]
    }
    p12.sig.nodes_k = sapply(unique(c(dis_mod_k, p2.sig.nodes_k)), trimws)
    p12.optBS = mle.getPtBSbyK(p12.sig.nodes_k, ranks)
    res = mle.getEncodingLength(p12.optBS, NULL, NULL, G)
    p12.e[k] = res[which.max(res[,"d.score"]), "IS.alt"] + log2(choose(length(G), 1))*(length(p12.sig.nodes_k)-which.max(res[,"d.score"]))
  }
  return (list(p1.e=p1.e, p2.e=p2.e, p12.e=p12.e,
               JAC = dirSim,
               NCD=(p12.e-apply(cbind(p1.e, p2.e), 1, min))/apply(cbind(p1.e, p2.e), 1, max)))
}

# First, run CTDdisMod for all models (kmx doesn't matter).
for (model in c("aadc", "abat", "adsl", "arg", "asld", "cit", "otc", "cob", "ga", "gamt", "msud", "mma", "pa", "zsd", "rcdp", "pku")) { # 
  load("clinical_data_Oct2020.RData")
  table(data_mx["argininosuccinate",])
  # Selected disease module
  mn = apply(data_mx[,which(colnames(data_mx) %in% cohorts[[model]])], 1, function(i) mean(na.omit(i)))
  mn = mn[-which(is.na(mn))]
  downtown_disease_module = disMod[[model]]
  # For each network fold, run CTDdm against several diagnoses
  for (fold in 1:length(cohorts[[model]])) {
    print(sprintf("Fold %d/%d...", fold, length(cohorts[[model]])))
    ig = loadToEnv(sprintf("graphs_GMpaper/bg_%s_fold%d.RData", model, fold))[["ig_pruned"]]
    ranks = loadToEnv(sprintf("ranks_GMpaper/%s%d-ranks.RData", model, fold))[["permutationByStartNode"]]
    ranks = lapply(ranks, tolower)
    adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
    G = vector(mode="list", length=length(V(ig)$name))
    names(G) = V(ig)$name
    data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
    data_mx = data_mx[,which(colnames(data_mx) %in% unlist(cohorts))]
    
    tmp.mm = unique(downtown_disease_module)
    tmp.mm = tmp.mm[which(tmp.mm %in% names(G))]
    ptBSbyK.dis = mle.getPtBSbyK(tmp.mm, ranks)
    res = mle.getEncodingLength(ptBSbyK.dis, NULL, ptID, G)
    downtown_disease_mod = names(which(ptBSbyK.dis[[which.max(res[,"d.score"])]]==1))
    ptBSbyK.dis = mle.getPtBSbyK(downtown_disease_mod, ranks)
    
    df_disMod = data.frame(ptID=character(), diag=character(), ctdDisMod=numeric(), jac=numeric(), stringsAsFactors = FALSE)
    for (p in 1:ncol(data_mx)) {
      #print(sprintf("Patient %d/%d...", p, ncol(data_mx)))
      ptID = colnames(data_mx)[p]
      if (ptID %in% unlist(cohorts)) {diag = names(cohorts)[which(unlist(lapply(cohorts, function(i) ptID %in% i)))]}else{diag = "reference"}
      # CTD: get module best explained by network's connectivity
      S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p]
      p2.sig.nodes = names(S)[1:length(downtown_disease_mod)]
      p2.optBS = mle.getPtBSbyK(p2.sig.nodes, ranks)
      ctdDisMod = disFromDowntown(downtown_disease_mod, ptBSbyK.dis, p2.sig.nodes, p2.optBS, ranks, G, mn, S)
      #if (ptID=="X606789") {print(min(ctdDisMod$NCD))}
      df_disMod[p, "ptID"] = colnames(data_mx)[p]
      df_disMod[p, "diag"] = diag[1]
      df_disMod[p, "ctdDisMod"] = min(ctdDisMod$NCD)
      df_disMod[p, "jac"] = min(ctdDisMod$JAC)
    }
    save(df_disMod, file=sprintf("model/ctdDisMod_%s_fold%d.RData", model, fold))
  }
}


# Next, run CTD on all models for K=30
for (kmx in c(30)) {
  for (model in c("aadc", "abat", "adsl", "arg", "asld", "cit", "otc", "cob", "ga", "gamt", "msud", "mma", "pa","zsd", "rcdp", "pku")) { # 
    load("clinical_data_Oct2020.RData")
    table(data_mx["argininosuccinate",])
    # For each network fold, runCTD against several diagnoses
    for (fold in 1:length(cohorts[[model]])) {
      ig = loadToEnv(sprintf("graphs_GMpaper/bg_%s_fold%d.RData", model, fold))[["ig_pruned"]]
      ranks = loadToEnv(sprintf("ranks_GMpaper/%s%d-ranks.RData", model, fold))[["permutationByStartNode"]]
      ranks = lapply(ranks, tolower)
      adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
      G = vector(mode="list", length=length(V(ig)$name))
      names(G) = V(ig)$name
      data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
      data_mx = data_mx[,which(colnames(data_mx) %in% unlist(cohorts))]
    
      df_ctd = data.frame(ptID=character(), S=character(), lenS=numeric(), optT=numeric(), fishers=numeric(), I0=numeric(), IA=numeric(), d=numeric(), stringsAsFactors = FALSE)
      r=1
      ptBSbyK = list()
      for (p in 1:ncol(data_mx)) {
        ptID = colnames(data_mx)[p]
        if (ptID %in% unlist(cohorts)) {diag = names(cohorts)[which(unlist(lapply(cohorts, function(i) ptID %in% i)))]}else{diag = "reference"}
        S = data_mx[order(abs(data_mx[,p]), decreasing = TRUE),p][1:kmx]
        ptBSbyK[[ptID]] = mle.getPtBSbyK(names(S), ranks)
        res = mle.getEncodingLength(ptBSbyK[[ptID]], NULL, ptID, G)
        #if (ptID=="X606789") {
        #  print(sprintf("Patient %d/%d...", p, ncol(data_mx)))
        #  print(max(res[,"d.score"]))
        #}
        for (k in 1:kmx) {
          df_ctd[r, "ptID"] = colnames(data_mx)[p]
          df_ctd[r, "diag"] = diag[1]
          df_ctd[r, "S"] = paste(names(S)[1:k], collapse="/")
          df_ctd[r, "lenS"] = k
          df_ctd[r, "optT"] = res[k, "opt.T"]
          df_ctd[r, "I0"] = res[k, "IS.null"]
          df_ctd[r, "IA"] = res[k, "IS.alt"]
          df_ctd[r, "d"] = res[k, "d.score"]
          r = r + 1
        }
      }
      save(ptBSbyK, df_ctd, file=sprintf("model/ctd_%s_fold%d_kmx%d.RData", model, fold, kmx))
    }
  }
}

# Rbind df_ctdDisMod to df_ctd
rm(list=ls())
cohorts = loadToEnv("clinical_data_Oct2020.RData")[["cohorts"]]
for (model in c("aadc", "abat", "adsl", "arg", "asld", "cit", "otc", "cob", "ga", "gamt", "msud", "mma", "pa", "zsd", "rcdp", "pku")) { # 
  for (fold in 1:length(cohorts[[model]])) {
    load(sprintf("model/ctdDisMod_%s_fold%d.RData", model, fold))
    for (kmx in c(30)) {
      load(sprintf("model/ctd_%s_fold%d_kmx%d.RData", model, fold, kmx))
      df = data.frame(ptID=character(), S=character(), lenS=numeric(), optT=numeric(),
                fishers=numeric(), I0=numeric(), IA=numeric(), d=numeric(), 
                ctdDisMod=numeric(), jac=numeric(), stringsAsFactors = FALSE)
      r = 1
      for (p in 1:nrow(df_disMod)) {
        for (k in 1:kmx) {
          df[r, "ptID"] = df_ctd[r,"ptID"]
          df[r, "diag"] = df_ctd[r,"diag"]
          df[r, "S"] = df_ctd[r,"S"]
          df[r, "lenS"] = df_ctd[r,"lenS"]
          df[r, "optT"] = df_ctd[r,"optT"]
          df[r, "I0"] = df_ctd[r,"I0"]
          df[r, "IA"] = df_ctd[r,"IA"]
          df[r, "d"] = df_ctd[r,"d"]
          df[r, "ctdDisMod"] = df_disMod[p,"ctdDisMod"]
          df[r, "jac"] = df_disMod[p,"jac"]
          r = r + 1
        }
      }
      save(ptBSbyK, df, file=sprintf("model/model_%s_fold%d_kmx%d.RData", model, fold, kmx))
      system(sprintf("rm model/ctd_%s_fold%d_kmx%d.RData", model, fold, kmx))
    }
    system(sprintf("rm model/ctdDisMod_%s_fold%d.RData", model, fold))
  }
}


# Collapse fold signal to LOOCV signal, where the test patients scores are averaged across folds, and cases
# signal is the left out fold score.
rm(list=ls())
require(CTD)
require(R.utils)
load("clinical_data_Oct2020.RData")
which(apply(data_mx, 2, function(i) sum(na.omit(i)==0)/length(na.omit(i)))==1)
for (kmx in c(30)) { # 
  for (model in c("aadc", "abat", "adsl", "arg", "asld", "cit", "otc", "cob", "ga", "gamt", "zsd", "rcdp", "msud", "mma", "pa", "pku")) { # 
    df_model = data.frame(fold=numeric(), pt=numeric(), bits=numeric(), ctdDisMod=numeric(), jac=numeric(), diag=character(), stringsAsFactors = FALSE)
    for (fold in 1:length(cohorts[[model]])) {
      df = loadToEnv(sprintf("model/model_%s_fold%d_kmx%d.RData", model, fold, kmx))[["df"]]
      pts = unique(df$ptID)
      df_best = data.frame(pt=numeric(), ptID=character(), bits=numeric(), diag=character(), 
                           ctdDisMod=numeric(), jac=numeric(), stringsAsFactors = FALSE)
      for (pt in 1:length(pts)) {
        pt_data = df[which(df$ptID==pts[pt]),]
        ptID = unique(df[which(df$ptID==pts[pt]), "ptID"])
        if (pt_data[1,"diag"]==model) { 
          df_best[pt, "pt"] = which(cohorts[[model]]==ptID) 
        }
        df_best[pt, "ptID"] = ptID
        df_best[pt, "bits"] = max(df[which(df$ptID==pts[pt]), "d"])-log2(nrow(pt_data))
        df_best[pt, "jac"] = pt_data[1, "jac"]
        df_best[pt, "diag"] = unique(pt_data[,"diag"])
        df_best[pt, "ctdDisMod"] = pt_data[1, "ctdDisMod"]
      }
      df_best$bits[which(df_best$bits<0)] = 0
      df_best$fold = rep(fold, nrow(df_best))
      df_model = rbind(df_model, df_best)
    }
    # Do not do multiple hypothesis test correction here.
    #df_model$bits = -log2(p.adjust(2^-(df_model$bits), method="fdr"))
    df_model$loocv = rep(0, nrow(df_model))
    df_model$loocv[which(df_model$pt==df_model$fold)] = 1
    df_model = df_model[-intersect(which(df_model$loocv==0), which(df_model$diag==model)), ]
    b_bits = cbind(unique(df_model$ptID), sapply(unique(df_model$ptID), function(i) mean(df_model[which(df_model$ptID==i),"bits"])))
    ctdDisMod_loocv = cbind(unique(df_model$ptID), sapply(unique(df_model$ptID), function(i) mean(df_model[which(df_model$ptID==i),"ctdDisMod"])))
    jac_loocv = cbind(unique(df_model$ptID), sapply(unique(df_model$ptID), function(i) mean(df_model[which(df_model$ptID==i),"jac"])))
    df_model = df_model[-which(duplicated(df_model$ptID)),]
    df_model = df_model[order(df_model$ptID),]
    b_bits = b_bits[order(b_bits[,1]),]
    ctdDisMod_loocv = ctdDisMod_loocv[order(ctdDisMod_loocv[,1]),]
    jac_loocv = jac_loocv[order(jac_loocv[,1]),]
    df_model$bits = as.numeric(b_bits[,2])
    df_model$ctdDisMod = as.numeric(ctdDisMod_loocv[,2])
    df_model$jac = as.numeric(jac_loocv[,2])
    print(any(is.na(df_model$bits)))
    print(any(is.na(df_model$ctdDisMod)))
    kmx = nrow(pt_data)
    save(df_model, file=sprintf("model/dd-%s-loocv-kmx%d.RData", model, kmx))
    #sapply(1:length(cohorts[[model]]), function(i) system(sprintf("rm model/model_%s_fold%d_kmx%d.RData", model, i, kmx)))
  }
}

# For each kmx, get a list of patient rankings across all 16 disease-specific network models
# Be sure to change ptIDs to coded ptIDs
rm(list=ls())
require(EmpiricalBrownsMethod)
setwd("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Clinical_paper/model/")
models = c("aadc", "abat", "adsl", "arg", "asld", "cit", "cob", "ga", "gamt", "mma", "msud", "otc", "pa", "pku", "rcdp", "zsd")
load("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Clinical_paper/clnms_map-macbook.RData")
ff = list.files(getwd(), pattern=sprintf("kmx%d.RData", 30))
dff = loadToEnv(ff[1])[["df_model"]]
pts = dff$ptID
for (kmx in seq(30, 30, 5)) {
  ff = list.files(getwd(), pattern=sprintf("kmx%d.RData", kmx))
  df_models = list()
  for (model in 1:length(models)) {
    df_model = loadToEnv(ff[model])[["df_model"]]
    ctd_pval_uncorrected = ifelse(2^-df_model[, "bits"]>1, 1, 2^-df_model[, "bits"])
    df_model$bits2 = -log2(p.adjust(2^-(df_model$bits), method="bonferroni"))
    ctd_pval = ifelse(2^-df_model[, "bits2"]>1, 1, 2^-df_model[, "bits2"])
    ctdDisMod_percentile = sapply(df_model[, "ctdDisMod"], function(i) length(which(df_model$ctdDisMod<=i))/nrow(df_model))
    combined_network = apply(cbind(ctd_pval, ctdDisMod_percentile), 1, function(i)  empiricalBrownsMethod(data_matrix = rbind(df_model$bits, df_model$ctdDisMod), p_values = i, TRUE)$P_test)
    names(ctd_pval) = df_model$ptID
    names(ctdDisMod_percentile) = df_model$ptID
    names(combined_network) = df_model$ptID
    df_models[[models[model]]][["ctd_pval_uncorrected"]] = ctd_pval_uncorrected
    df_models[[models[model]]][["ctd_pval"]] = ctd_pval
    df_models[[models[model]]][["ctdDisMod_percentile"]] = ctdDisMod_percentile
    df_models[[models[model]]][["combined_network"]] = combined_network
  }
  
  pt_ranks = list()
  for (pt in 1:length(pts)) {
    ptID = pts[pt]
    ptID_coded = clnms_map[which(clnms_map[,1]==ptID), 2]
    for (pc in ptID_coded) {
      df_pt = data.frame(model=character(), ctd=numeric(), ctdDisMod=numeric(), brown.comb=numeric(), stringsAsFactors = FALSE)
      r = 1
      for (model in 1:length(models)) {
        ctd_pval = df_models[[models[model]]][["ctd_pval"]]
        ctdDisMod_percentile = df_models[[models[model]]][["ctdDisMod_percentile"]]
        combined_network = df_models[[models[model]]][["combined_network"]]
        
        df_pt[r, "model"] = gsub(sprintf("dd-|-loocv-kmx%d.RData", kmx), "", ff[model])
        df_pt[r, "ctd"] = ctd_pval[pt]
        df_pt[r, "ctdDisMod"] = ctdDisMod_percentile[pt]
        df_pt[r, "brown.comb"] = combined_network[pt]   # Use Brown's combined for dependent tests
        r = r + 1
      }
      pt_ranks[[pc]] = df_pt
    }
  }
  save(pt_ranks, file=sprintf("ptRanks_kmx%d.RData", kmx))
}


# AUCs
setwd("../")
require(pROC)
require(pls)
require(EmpiricalBrownsMethod)
dff = data.frame(kmx=numeric(), model=character(), ctd.auc=numeric(), ctddismod.auc=numeric(),
                 jac.auc=numeric(), combined.auc=numeric(), stringsAsFactors = FALSE)
r= 1
for (model in c("aadc", "abat", "adsl", "arg", "asld", "cit", "cob", "ga", "gamt", "msud", "mma", "otc", "pa", "pku", "rcdp", "zsd")) {
  for (kmx in seq(30,30,5)) {
    print(sprintf("MODEL %s...", model))
    # df_model$bits add Bonferroni correction
    load(sprintf("model/dd-%s-loocv-kmx%d.RData", model, kmx))
    df_model = df_model[-which(df_model$diag=="maps"),]
    df_model$bits = -log2(p.adjust(2^-(df_model$bits), method="bonferroni"))
    df_model$diag = gsub("test_", "", df_model$diag)
    print(toupper(model))
    print(dim(df_model))
    diags = df_model$diag
    diags[-which(diags==model)] = 0
    diags[which(diags==model)] = 1
    
    # AUC, CTD only
    ctd.auc = roc(diags, df_model$bits)
    print(ctd.auc$auc)
    # AUC, CTDdisMod only
    #ctddismod.auc = roc(diags, df_model$ctdDisMod)
    #print(ctddismod.auc$auc)
    # AUC, Jaccard only
    #jac.auc = roc(diags, df_model$jac)
    #print(jac.auc$auc)
  
    # AUC, Network-combined: CTD+CTDdisMod
    ctd_pvals = 2^-(df_model$bits)
    ctdDisMod_pvals = sapply(df_model$ctdDisMod, function(i) length(which(df_model$ctdDisMod<=i))/nrow(df_model))
    combined_brown = apply(cbind(ctd_pvals, ctdDisMod_pvals), 1, function(i)  empiricalBrownsMethod(data_matrix = rbind(df_model$bits, df_model$ctdDisMod), p_values = i, TRUE)$P_test)
    network.auc = roc(diags, combined_brown)
    print(network.auc$auc)
    
    # AUC, all CTD+CTDdisMod+Jaccard, Browns combined
    ctd_pvals = 2^-(df_model$bits)
    ctdDisMod_pvals = sapply(df_model$ctdDisMod, function(i) length(which(df_model$ctdDisMod<=i))/nrow(df_model))
    jac_pvals = sapply(df_model$jac, function(i) length(which(df_model$jac<=i))/nrow(df_model))
    combined_brown = apply(cbind(ctd_pvals, ctdDisMod_pvals, jac_pvals), 1, function(i)  empiricalBrownsMethod(data_matrix = rbind(df_model$bits, df_model$ctdDisMod, df_model$jac), p_values = i, TRUE)$P_test)
    all.auc = roc(diags, combined_brown)
    print(all.auc$auc)
    
    dff[r, "kmx"] = kmx
    dff[r, "model"] = model
    dff[r, "ctd.auc"] = ctd.auc$auc
    #dff[r, "ctddismod.auc"] = ctddismod.auc$auc
    #dff[r, "jac.auc"] = jac.auc$auc
    dff[r, "network.auc"] = network.auc$auc
    dff[r, "all.auc"] = all.auc$auc
    r = r + 1
  }
}

#require(ggplot2)
#dff$kmx = as.factor(dff$kmx)
#ggplot(dff) + geom_bar(aes(x=kmx, y=ctd.auc), stat="identity") + facet_wrap(~model)

```

## Compare Usefulness of Information Mined in a Pathway Context to an Unbiased Network Context
``` {r pathway-vs-ctd-global}
# Pathway discrimination: PLS w/ metabolies in urea cycle. Diagnose patients for urea cycle defects.
# CTD Global discrimination: CTD disease specific models call "yes" or "no" based on significance of patient's top metabolite perturbations.
rm(list=ls())
require(CTD)
require(R.utils)
require(pls)
require(pROC)
kmx=30
p0=0.1
p1=0.9
thresholdDiff=0.01
load("clinical_data_Oct2020.RData")
refs = data_mx[,which(colnames(data_mx) %in% cohorts$edta_refs)]
#cohorts$arg = c(cohorts$arg, cohorts$test_arg)
#cohorts$asld = c(cohorts$asld, cohorts$test_asld)
#cohorts$otc = c(cohorts$otc, cohorts$test_otc)
cohorts = cohorts[-which(names(cohorts) %in% c("maps", "abat", "aadc", "adsl", "zsd", "rcdp", "test_arg", "test_asld", "test_otc", "cob", "ga", "gamt", "msud", "mma", "pa", "pku", "hep_refs"))]
data_mx = data_mx[,which(colnames(data_mx) %in% c(unlist(cohorts)))]
fill.rate = apply(data_mx, 1, function(i) sum(is.na(i))/length(i))
data_mx = data_mx[which(fill.rate<0.20),]
data_mx = data_mx[,sort(colnames(data_mx))]
print(dim(data_mx))

table(data_mx["argininosuccinate",])
data_mx["argininosuccinate", which(data_mx["argininosuccinate",]!=0)] = 1

load("~/Downloads/CTDext/inst/extdata/RData/Arginine-Metabolism.RData")
uc_pathway_mets = V(ig)$label[which(V(ig)$shape=="circle")]
uc_pathway_mets = uc_pathway_mets[-which(uc_pathway_mets %in% c("H2O", "FAD", "O2", "NADP+", "CO2", "ADP", "NADH", "ATP", "PPi", "H+", "Mg2+", "Ca2+", "FMN", "PLP", "AMP", "Mg2+", "Mn2+", "NAD+", "ARGININE METABOLISM AND UREA CYCLE", "Aspartate Glutamate Metabolism", "Proline Metabolism", "Polyamine Metabolism", "TCA Cycle", "Pi"))]
uc_pathway_mets = uc_pathway_mets[-which(uc_pathway_mets %in% c("NADPH", "Co2+", "NH3"))]
uc_pathway_metsAll = tolower(uc_pathway_mets)
uc_pathway_metsLocal = c("argininosuccinate", "citrulline", "arginine", "ornithine")
dff_all = data.frame(diag=character(), model=character(), sensitivity=numeric(), specificity=numeric(), stringsAsFactors = FALSE)
for (model in c("arg", "asld", "cit", "otc")) {
  print(sprintf("%s...", toupper(model)))
  diags = colnames(data_mx)
  diags[which(!(diags %in% cohorts[[model]]))] = 0
  diags[which(diags %in% cohorts[[model]])] = 1
  
  # Data frame for pathway (local) view - PLS on zscores, predicting diagnosis (0=control, 1=case)
  uc_data = rbind(diags, data_mx)
  rownames(uc_data)[1] = "diag"
  uc_data = uc_data[which(rownames(uc_data) %in% c("diag", uc_pathway_metsLocal)),]
  uc_data = apply(uc_data, c(1,2), as.numeric)
  
  # Full pathway view
  uc_data2 = rbind(diags, data_mx)
  rownames(uc_data2)[1] = "diag"
  uc_data2 = uc_data2[which(rownames(uc_data2) %in% c("diag", uc_pathway_metsAll)),]
  uc_data2 = apply(uc_data2, c(1,2), as.numeric)

  # Data frame for CTD/CTDdisMod network-quantified variables
  load(sprintf("model/dd-%s-loocv-kmx%d.RData", model, kmx))
  df_model = df_model[which(df_model$ptID %in% colnames(data_mx)),]
  df_model$bits = -log2(p.adjust(2^-(df_model$bits), method="bonferroni"))
  ctd_pvals = 2^-(df_model$bits)
  ctdDisMod_pvals = sapply(df_model$ctdDisMod, function(i) length(which(df_model$ctdDisMod<=i))/nrow(df_model))
  combined_brown = apply(cbind(ctd_pvals, ctdDisMod_pvals), 1, function(i)  empiricalBrownsMethod(data_matrix = rbind(df_model$bits, df_model$ctdDisMod), p_values = i, TRUE)$P_test)
  #df2_ctd = data.frame(combined=combined_brown, ctd=df_model$bits, ctddisMod=df_model$ctdDisMod, diag=as.numeric(diags))  # 
  df2_ctd = data.frame(combined=-log2(combined_brown), ctd=df_model$bits, ctddisMod=-log2(ctdDisMod_pvals), diag=as.numeric(diags))  # 
  #df2_ctd = data.frame(combined=-log2(combined_brown), diag=as.numeric(diags))  # 
  rownames(df2_ctd) = df_model$ptID
  
  # LOOCV PLS
  dff_model = data.frame(pls_pwyLocal=numeric(), pls_pwyAll=numeric(), pls_ctd_ctddm=numeric(), stringsAsFactors = FALSE)
  for (it in 1:length(diags)) {
    isTrain = c(1:length(diags))[-it]
    # Pathway Z-score feature selection: Local
    model_res = plsr(diag~., data = as.data.frame(t(uc_data[,isTrain])))
    tst_data = uc_data[,-isTrain]
    model_tst =  predict(model_res, ncomp=model_res$ncomp, newdata=as.data.frame(t(tst_data)))
    dff_model[it, "pls_pwyLocal"] = model_tst
    
    # Pathway Z-score feature selection: All
    model_res = plsr(diag~., data = as.data.frame(t(uc_data2[,isTrain])))
    tst_data = uc_data2[,-isTrain]
    if (length(which(is.na(tst_data))) >0) {
      tst_data[which(is.na(tst_data))] = min(na.omit(uc_data2[which(is.na(tst_data)),]))
    }
    model_tst =  predict(model_res, ncomp=model_res$ncomp, newdata=as.data.frame(t(tst_data)))
    dff_model[it, "pls_pwyAll"] = model_tst
    
    # CTD and CTDdm as covariates
    ctd_res = plsr(diag~., data = df2_ctd[isTrain,])
    tst_data = as.matrix(df2_ctd[-isTrain,-which(colnames(df2_ctd)=="diag")])
    if (ncol(tst_data)==1) { colnames(tst_data) = "combined" }
    ctd_tst = predict(ctd_res, ncomp=ctd_res$ncomp, newdata=tst_data)
    dff_model[it, "pls_ctd_ctddm"] = ctd_tst
  }

  pls_ctd_auc = roc(diags, dff_model$pls_ctd_ctddm)
  pls_pwyLocal_auc = roc(diags, dff_model$pls_pwyLocal)
  pls_pwyAll_auc = roc(diags, dff_model$pls_pwyAll)
  print(sprintf("PLS.ctd.ctddisMod  AUC = %.3f", pls_ctd_auc$auc))
  print(sprintf("PLS.pathwayLocal     AUC = %.3f", pls_pwyLocal_auc$auc))
  print(sprintf("PLS.pathwayAll     AUC = %.3f", pls_pwyAll_auc$auc))

  ind = which(duplicated(pls_pwyLocal_auc$specificities))
  ind2 = which(duplicated(pls_pwyAll_auc$specificities))
  ind3 = which(duplicated(pls_ctd_auc$specificities))
  
  dff2 = data.frame(diag=character(), model=character(), sensitivity=numeric(), specificity=numeric(), stringsAsFactors = FALSE)
  nrw = 3+length(pls_pwyLocal_auc$specificities[-ind]) + length(pls_pwyAll_auc$specificities[-ind2]) + length(pls_ctd_auc$specificities[-ind3])
  dff2[1:nrw, "diag"] = rep(model, nrw)
  dff2[1:nrw, "model"] = c(rep("pls-pwyLocal", 1+length(pls_pwyLocal_auc$specificities[-ind])), 
                           rep("pls-pwyAll", 1+length(pls_pwyAll_auc$specificities[-ind2])),
                           rep("plsctd", 1+length(pls_ctd_auc$specificities[-ind3])))
  dff2[1:nrw, "specificity"] = c(pls_pwyLocal_auc$specificities[-ind], 1, pls_pwyAll_auc$specificities[-ind2], 1, pls_ctd_auc$specificities[-ind3], 1)
  dff2[1:nrw, "sensitivity"] = c(pls_pwyLocal_auc$sensitivities[-ind], 0, pls_pwyAll_auc$sensitivities[-ind2], 0, pls_ctd_auc$sensitivities[-ind3], 0)

  dff_all = rbind(dff_all, dff2)
}

require(ggplot2)
svg("pathway-vs-global/pwy-vs-global_MJM_v1.svg")
ggplot(dff_all) + geom_line(aes(x=1-specificity, y=sensitivity, colour=model), size=1.5) + facet_wrap(~diag)
dev.off()

png("pathway-vs-global/pwy-vs-global_MJM_v1.png")
ggplot(dff_all) + geom_line(aes(x=1-specificity, y=sensitivity, colour=model), size=1.5) + facet_wrap(~diag)
dev.off()

```

# Haijes et al 2020 Comparison: Rank Diagnoses for Each Patient
``` {r rank-diagnoses}
rm(list=ls())
# 16 models for k=30
for (kmx in seq(30,30,5)) {
  dff = data.frame(model=character(), ptID=character(), diag=character(), ctd_pval=numeric(), ctdDisMod_pval=numeric(), combined_pval=numeric(), stringsAsFactors = FALSE)
  r = 1
  print(sprintf("Kmx = %d", kmx))
  # Include "asld" and "otc" in the 16 model run, then comment them out for 14 model run.
  for (model in c("aadc", "abat", "adsl", "arg", "cit", "cob", "ga", "gamt", "msud", "mma", "pa", "pku", "rcdp", "zsd", "asld", "otc")) { #
    print(sprintf("MODEL %s...", model))
    load(sprintf("model/dd-%s-loocv-kmx%d.RData", model, kmx))
    # df_model$bits is already FDR corrected
    df_model$bits = -log2(p.adjust(2^-(df_model$bits), method="bonferroni"))
    df_model$diag = gsub("test_", "", df_model$diag)
    # Excluse OTC and ASLD for 14 model run. Only rank diagnosed patients (not healthy control reference patients).
    df_model = df_model[-which(df_model$diag %in% c("maps", "hep_refs", "edta_refs")),]   # "otc", "asld"
    
    ctd_pvals = ifelse(2^-(df_model$bits)>1, 1, 2^-(df_model$bits))
    ctdDisMod_pvals = sapply(df_model$ctdDisMod, function(i) length(which(df_model$ctdDisMod<=i))/nrow(df_model))
    jac_pvals = sapply(df_model$jac, function(i) length(which(df_model$jac<=i))/nrow(df_model))
    #combined_hm = apply(cbind(ctd_pvals, ctdDisMod_pvals, jac_pvals), 1, function(i) mean(i))
    combined_brown = apply(cbind(ctd_pvals, ctdDisMod_pvals, jac_pvals), 1, function(i)  empiricalBrownsMethod(data_matrix = rbind(df_model$bits, df_model$ctdDisMod, df_model$jac), p_values = i, TRUE)$P_test)
    #combined_fisher = apply(cbind(ctd_pvals, ctdDisMod_pvals, jac_pvals), 1, function(i) stats.fishersMethod(i))
    
    for (pt in 1:nrow(df_model)) {
      dff[r, "model"] = model
      dff[r, "ptID"] = df_model$ptID[pt]
      dff[r, "diag"] = df_model$diag[pt]
      dff[r, "ctd_pval"] = ctd_pvals[pt]
      dff[r, "ctdDisMod_pval"] = ctdDisMod_pvals[pt]
      dff[r, "combined_pval"] = combined_brown[pt]
      r = r + 1
    }
  }

  # CTD only
  # Top 1 is correct diagnosis
  top1 = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][which.min(dff[which(dff$ptID==i), "ctd_pval"]),c("model", "diag")])
  top1 = sum(unlist(apply(top1, 2, function(i) i$model==i$diag)))/length(unique(dff$ptID))
  print(top1)
  # Top 3 is correct diagnosis
  top3 = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][order(dff[which(dff$ptID==i), "ctd_pval"], decreasing = FALSE)[1:3],c("model", "diag")])
  top3 = sum(unlist(apply(top3, 2, function(i) i$diag[1] %in% i$model)))/length(unique(dff$ptID))
  print(top3)
  # Length of DD
  len_dd = unlist(sapply(unique(dff$ptID), function(i) length(which(dff[which(dff$ptID==i),"ctd_pval"]<0.05))))
  print(median(len_dd))
  print(quantile(len_dd, 0.05))
  print(quantile(len_dd, 0.95))
  # Percentage in DD
  dd = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][which(dff[which(dff$ptID==i),"ctd_pval"]<0.05), c("model", "diag")])
  dd = sum(unlist(apply(dd, 2, function(i) i$diag[1] %in% i$model)))/length(unique(dff$ptID))
  print(dd)
  
  # CTDdisMod only
  # Top 1 is correct diagnosis
  top1 = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][which.min(dff[which(dff$ptID==i), "ctdDisMod_pval"]),c("model", "diag")])
  top1 = sum(unlist(apply(top1, 2, function(i) i$model==i$diag)))/length(unique(dff$ptID))
  print(top1)
  # Top 3 is correct diagnosis
  top3 = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][order(dff[which(dff$ptID==i), "ctdDisMod_pval"], decreasing = FALSE)[1:3],c("model", "diag")])
  top3 = sum(unlist(apply(top3, 2, function(i) i$diag[1] %in% i$model)))/length(unique(dff$ptID))
  print(top3)
  # Length of DD
  len_dd = unlist(sapply(unique(dff$ptID), function(i) length(which(dff[which(dff$ptID==i),"ctdDisMod_pval"]<0.05))))
  print(median(len_dd))
  print(quantile(len_dd, 0.05))
  print(quantile(len_dd, 0.95))
  # Percentage in DD
  dd = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][which(dff[which(dff$ptID==i),"ctdDisMod_pval"]<0.05), c("model", "diag")])
  dd = sum(unlist(apply(dd, 2, function(i) i$diag[1] %in% i$model)))/length(unique(dff$ptID))
  print(dd)

  # Combined Network 
  # Top 1 is correct diagnosis
  top1 = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][which.min(dff[which(dff$ptID==i), "combined_pval"]),c("model", "diag")])
  top1 = sum(unlist(apply(top1, 2, function(i) i$model==i$diag)))/length(unique(dff$ptID))
  print(top1)
  # Top 3 is correct diagnosis
  top3 = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][order(dff[which(dff$ptID==i), "combined_pval"], decreasing = FALSE)[1:3],c("model", "diag")])
  top3 = sum(unlist(apply(top3, 2, function(i) i$diag[1] %in% i$model)))/length(unique(dff$ptID))
  print(top3)
  # Length of DD
  len_dd = unlist(sapply(unique(dff$ptID), function(i) length(which(dff[which(dff$ptID==i),"combined_pval"]<0.05))))
  print(median(len_dd))
  print(quantile(len_dd, 0.05))
  print(quantile(len_dd, 0.95))
  # Percentage in DD
  dd = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][which(dff[which(dff$ptID==i),"combined_pval"]<0.05), c("model", "diag")])
  dd = sum(unlist(apply(dd, 2, function(i) i$diag[1] %in% i$model)))/length(unique(dff$ptID))
  print(dd)
}

# 15 models for k=30
for (kmx in seq(30,30,5)) {
  dff = data.frame(model=character(), ptID=character(), diag=character(), ctd_pval=numeric(), ctdDisMod_pval=numeric(), combined_pval=numeric(), stringsAsFactors = FALSE)
  r = 1
  print(sprintf("Kmx = %d", kmx))
  # Include "asld" and "otc" in the 16 model run, then comment them out for 14 model run.
  for (model in c("aadc", "abat", "adsl", "arg", "asld", "cit", "cob", "ga", "gamt", "msud", "mma", "pa", "pku", "rcdp", "zsd")) { #
    print(sprintf("MODEL %s...", model))
    load(sprintf("model/dd-%s-loocv-kmx%d.RData", model, kmx))
    # df_model$bits is already FDR corrected
    df_model$bits = -log2(p.adjust(2^-(df_model$bits), method="bonferroni"))
    df_model$diag = gsub("test_", "", df_model$diag)
    # Excluse OTC and ASLD for 14 model run. Only rank diagnosed patients (not healthy control reference patients).
    df_model = df_model[-which(df_model$diag %in% c("maps", "hep_refs", "edta_refs", "otc")),]  
    
    ctd_pvals = ifelse(2^-(df_model$bits)>1, 1, 2^-(df_model$bits))
    ctdDisMod_pvals = sapply(df_model$ctdDisMod, function(i) length(which(df_model$ctdDisMod<=i))/nrow(df_model))
    jac_pvals = sapply(df_model$jac, function(i) length(which(df_model$jac<=i))/nrow(df_model))
    combined_brown = apply(cbind(ctd_pvals, ctdDisMod_pvals, jac_pvals), 1, function(i)  empiricalBrownsMethod(data_matrix = rbind(df_model$bits, df_model$ctdDisMod, df_model$jac), p_values = i, TRUE)$P_test)

    for (pt in 1:nrow(df_model)) {
      dff[r, "model"] = model
      dff[r, "ptID"] = df_model$ptID[pt]
      dff[r, "diag"] = df_model$diag[pt]
      dff[r, "ctd_pval"] = ctd_pvals[pt]
      dff[r, "ctdDisMod_pval"] = ctdDisMod_pvals[pt]
      dff[r, "combined_pval"] = combined_brown[pt]
      r = r + 1
    }
  }

  # Combined Network 
  # Top 1 is correct diagnosis
  top1 = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][which.min(dff[which(dff$ptID==i), "combined_pval"]),c("model", "diag")])
  top1 = sum(unlist(apply(top1, 2, function(i) i$model==i$diag)))/length(unique(dff$ptID))
  print(top1)
  # Top 3 is correct diagnosis
  top3 = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][order(dff[which(dff$ptID==i), "combined_pval"], decreasing = FALSE)[1:3],c("model", "diag")])
  top3 = sum(unlist(apply(top3, 2, function(i) i$diag[1] %in% i$model)))/length(unique(dff$ptID))
  print(top3)
  # Length of DD
  len_dd = unlist(sapply(unique(dff$ptID), function(i) length(which(dff[which(dff$ptID==i),"combined_pval"]<0.05))))
  print(median(len_dd))
  print(quantile(len_dd, 0.05))
  print(quantile(len_dd, 0.95))
  # Percentage in DD
  dd = sapply(unique(dff$ptID), function(i) dff[which(dff$ptID==i),][which(dff[which(dff$ptID==i),"combined_pval"]<0.05), c("model", "diag")])
  dd = sum(unlist(apply(dd, 2, function(i) i$diag[1] %in% i$model)))/length(unique(dff$ptID))
  print(dd)
}


# Get number of DDs in reference patients only
dff = data.frame(model=character(), ptID=character(), diag=character(), ctd_pval=numeric(), ctdDisMod_pval=numeric(), combined_pval=numeric(), stringsAsFactors = FALSE)
r = 1
for (model in c("aadc", "abat", "adsl", "arg", "asld", "cit", "cob", "ga", "gamt", "msud", "mma", "otc", "pa", "pku", "rcdp", "zsd")) { 
  print(sprintf("MODEL %s...", model))
  load(sprintf("model/dd-%s-loocv-kmx30.RData", model))
  df_model$bits = -log2(p.adjust(2^-df_model$bits, method="bonferroni"))
  df_model$diag = gsub("test_", "", df_model$diag)
  df_model = df_model[which(df_model$diag %in% c("hep_refs", "edta_refs")),]
  
  ctd_pvals = ifelse(2^-(df_model$bits)>1, 1, 2^-(df_model$bits))
  ctdDisMod_pvals = sapply(df_model$ctdDisMod, function(i) length(which(df_model$ctdDisMod<=i))/nrow(df_model))
  jac_pvals = sapply(df_model$jac, function(i) length(which(df_model$jac<=i))/nrow(df_model))
  combined_brown = apply(cbind(ctd_pvals, ctdDisMod_pvals, jac_pvals), 1, function(i)  empiricalBrownsMethod(data_matrix = rbind(df_model$bits, df_model$ctdDisMod, df_model$jac), p_values = i, TRUE)$P_test)

  for (pt in 1:nrow(df_model)) {
    dff[r, "model"] = model
    dff[r, "ptID"] = df_model$ptID[pt]
    dff[r, "diag"] = df_model$diag[pt]
    dff[r, "ctd_pval"] = ctd_pvals[pt]
    dff[r, "ctdDisMod_pval"] = ctdDisMod_pvals[pt]
    dff[r, "combined_pval"] = combined_brown[pt]
    r = r + 1
  }
}
# Length of DD
len_dd = unlist(sapply(unique(dff$ptID), function(i) length(which(dff[which(dff$ptID==i),"combined_pval"]<0.05))))
median(len_dd)
quantile(len_dd, 0.05)
quantile(len_dd, 0.95)

```

## Zellweger Spectrum Disorders: PEX1 (Peroxisome Biogenesis disorders) vs. PEX7 (RCDP)
``` {r single-node_ptSim}
rm(list=ls())
# Compute the patient similarity between negative controls, true cases and the "unknown disease" patient cohort.
require(R.utils)
require(CTD)
thresholdDiff=0.01
kmx=30
p0=0.1
p1=0.9
load("clinical_data_Oct2020.RData")
data_mx = data_mx[-grep("x - ", rownames(data_mx)),]
refs = data_mx[,which(colnames(data_mx) %in% cohorts$edta_refs)]
data_mx = data_mx[,which(colnames(data_mx) %in% unlist(cohorts))]
for (model in c("rcdp", "zsd")) { 
  for (fold in 1:length(cohorts[[model]])) {
    # Load pre-computed node ranks (run on cluster in parallel and collated)
    ranks = loadToEnv(sprintf("ranks/%s%d-ranks.RData", toupper(model), fold))[["permutationByStartNode"]]
    ranks = lapply(ranks, tolower)
    names(ranks) = as.character(lapply(ranks, function(i) i[[1]][1]))
    ig = loadToEnv(sprintf("graphs/bg_%s_fold%d.RData", model, fold))[["ig_pruned"]]
    adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
    data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]

    # Get patient bitstrings ahead of time
    ptBSbyK = list()
    for (pt in 1:ncol(data_mx)) {
      print(pt)
      ptID = colnames(data_mx)[pt]
      S1 = rownames(data_mx)[order(abs(data_mx[,ptID]), decreasing = TRUE)][1:kmx]
      ptBSbyK[[ptID]] = singleNode.getPtBSbyK(S1, ranks)
    }

    res = list()
    t = list(ncd=matrix(NA, nrow=ncol(data_mx), ncol=ncol(data_mx)), jac=matrix(NA, nrow=ncol(data_mx), ncol=ncol(data_mx)))
    rownames(t$ncd) = colnames(data_mx)
    colnames(t$ncd) = colnames(data_mx)
    rownames(t$jac) = colnames(data_mx)
    colnames(t$jac) = colnames(data_mx)
    for (i in 1:(kmx-1)) { res[[i]] = t }
    for (pt in 1:(ncol(data_mx)-1)) {
      print(pt)
      ptID = colnames(data_mx)[pt]
      for (pt2 in (pt+1):ncol(data_mx)) {  
        print(sprintf(" vs. %d...", pt2))
        ptID2 = colnames(data_mx)[pt2]
        tmp = mle.getPtSim(ptBSbyK[[ptID]], ptID, ptBSbyK[[ptID2]], ptID2, data_mx, ranks)
        for (k in 1:(kmx-1)) {
          res[[k]]$ncd[ptID, ptID2] = tmp$NCD[k]
          res[[k]]$jac[ptID, ptID2] = tmp$dirSim[k]
          res[[k]]$ncd[ptID2, ptID] = tmp$NCD[k]
          res[[k]]$jac[ptID2, ptID] = tmp$dirSim[k]
        }
      }
    }
    # Normalize rows by max value size k
    res_norm = res
    for (k in 1:(kmx-1)) {
      diag(res_norm[[k]]$ncd) = 0
      diag(res_norm[[k]]$jac) = 0
      res_norm[[k]]$ncd = res_norm[[k]]$ncd/max(na.omit(res_norm[[k]]$ncd))
    }
    save(res, res_norm, file=sprintf("ptSim/ptSim_%s%d_kmx%d.RData", model, fold, kmx))
  }
}


# For RCDP and ZSD similarity matrices, take the min patient distance for each k, and then across k, for each pairwise patient comparison. You will end up with one similarity matrix.
rm(list=ls())
require(CTD)
require(R.utils)
load("clinical_data_July2020.RData")
kmx=30
mle.getMeanPtDistance = function (allSimMatrices) {
  ptSim = allSimMatrices[[1]]
  for (ind in 2:length(allSimMatrices)) {
    ptSim = ptSim + allSimMatrices[[ind]]
  }
  ptSim = ptSim/length(allSimMatrices)
  return(ptSim)
}
all_models_list = list()
for (model in c("rcdp", "zsd")) {
  print(model)
  model_list = list()
  for (fold in 1:length(cohorts[[model]])) {
    print(fold)
    res = loadToEnv(sprintf("ptSim/kmx%d/ptSim_%s%d_kmx%d.RData", kmx, model, fold, kmx))[["res"]]
    res = lapply(res, function(i) i$ncd)
    model_list[[fold]] = mle.getMinPtDistance(res)
  }
  res_ncd = mle.getMeanPtDistance(model_list)
  diag(res_ncd) = 0
  res_ncd = res_ncd / max(res_ncd)
  # Get colnames
  res = loadToEnv(sprintf("ptSim/kmx%d/ptSim_%s%d_kmx%d.RData", kmx, model, 1, kmx))[["res"]]
  colnames(res_ncd) = colnames(res[[1]]$ncd)
  rownames(res_ncd) = colnames(res[[1]]$ncd)
  all_models_list[[model]] = res_ncd
}
#save(all_models_list, file=sprintf("ptSim/all_models_list_kmx%d.RData", kmx))

rm(list=ls())
kmx=30
load(sprintf("ptSim/all_models_list_kmx%d.RData", kmx))
load("clinical_data_July2020.RData")
#wangler_ages10_andDown = c("449", "450", "451", "452", "453", "455", "456", "457", "458", "743", "752")
wangler_ages10_andDown = c("FAM10", "FAM11", "FAM12", "FAM16", "FAM18", "FAM19", "FAM20", "FAM22", "FAM23", "FAM26", "FAM27")
data_mx = data_mx[-grep("x - ", rownames(data_mx)),]
refs = data_mx[,which(colnames(data_mx) %in% cohorts$edta_refs)]
res_overall = mle.getMeanPtDistance(all_models_list)
diag(res_overall) = 0
res_overall = res_overall / max(res_overall)
colnames(res_overall) = colnames(all_models_list[[1]])
ind = which(colnames(res_overall) %in% unlist(cohorts[c("zsd", "rcdp", "edta_refs")]))
res_overall = res_overall[ind, ind]
diags = colnames(res_overall)
diags[which(diags %in% wangler_ages10_andDown)] = "ZSD (<10 y.o.)"
diags[which(diags %in% cohorts$zsd)] = "ZSD (10+ y.o.)" 
diags[which(diags %in% cohorts$rcdp)] = "RCDP"
diags[which(diags %in% cohorts$edta_refs)] = "REF"

fitSim = cmdscale(res_overall, eig = FALSE, k = 2)
x = round(fitSim[, 1], 2)
y = round(fitSim[, 2], 2)
#z = round(fitSim[, 3], 2)
#df = data.frame(x = x, y = y, z = z, color = diags, label = colnames(res_overall))
#p = plot_ly(df, x = ~x, y = ~y, z = ~z, color = ~color, text = ~label, marker = list(size = 20))
df = data.frame(x = x, y = y, color = diags, label = colnames(res_overall))
p = plot_ly(df, x = ~x, y = ~y, color = ~color, text = ~label, marker = list(size = 20))
orca(p, sprintf("ptSim/CTDncd_origZscore_kmx%d.svg", kmx), format = "svg")

# Get UNK patients that cluster with PEX1 or PEX7 samples
# Kmeans
zsd.centroid = apply(res_overall[grep("ZSD", diags),], 2, mean)
rcdp.centroid = apply(res_overall[which(diags=="RCDP"),], 2, mean)
ref.centroid = apply(res_overall[which(diags=="REF"),], 2, mean)
kmns = kmeans(res_overall, centers = rbind(zsd.centroid, rcdp.centroid, ref.centroid))
df = cbind(as.numeric(kmns$cluster), diags, colnames(all_models_list[[1]])[ind])
colnames(df) = c("cluster.num", "diag", "ptID")
zsd.cluster = df[which(df[,1]=="1"), ]
rcdp.cluster = df[which(df[,1]=="2"), ]
ref.cluster = df[which(df[,1]==3), ]
clusterPurity <- function(clusters, classes) {
  sum(apply(table(classes, clusters), 2, max)) / length(clusters)
}
clusterPurity(df[,1], df[,2])


# Compare to euclidean distance + MDS
load("clinical_data_Oct2020.RData")
data_mx = data_mx[,which(colnames(data_mx) %in% c(cohorts$zsd, cohorts$rcdp, cohorts$edta_refs))]
ptSim_euc = as.matrix(dist(t(data_mx), method="euclidean"))
fitSim = cmdscale(ptSim_euc, eig = FALSE, k = 2)
x = round(fitSim[, 1], 2)
y = round(fitSim[, 2], 2)
df = data.frame(x = x, y = y, color = diags, label = colnames(res_overall))
p_euc = plot_ly(df, x = ~x, y = ~y, color = ~color, text = ~label, marker = list(size = 20))
orca(p_euc, sprintf("ptSim/zsd_rcdp_euc_origZscore.svg"), format = "svg")

zsd.centroid = apply(ptSim_euc[which(colnames(ptSim_euc) %in% cohorts$zsd),], 2, mean)
rcdp.centroid = apply(ptSim_euc[which(colnames(ptSim_euc) %in% cohorts$rcdp),], 2, mean)
ref.centroid = apply(ptSim_euc[which(colnames(ptSim_euc) %in% cohorts$edta_refs),], 2, mean)
kmns = kmeans(ptSim_euc, centers = rbind(zsd.centroid, rcdp.centroid, ref.centroid))
df = cbind(as.numeric(kmns$cluster), diags, colnames(all_models_list[[1]])[ind])
colnames(df) = c("cluster.num", "diag", "ptID")
zsd.cluster = df[which(df[,1]=="1"), ]
rcdp.cluster = df[which(df[,1]=="2"), ]
ref.cluster = df[which(df[,1]==3), ]
clusterPurity <- function(clusters, classes) {
  sum(apply(table(classes, clusters), 2, max)) / length(clusters)
}
clusterPurity(df[,1], df[,2])


# Compare to mahalanobis distance + basic plot
require(CTDext)
data_mx = data.imputeData(data_mx, data_mx[,which(colnames(data_mx) %in% cohorts$edta_refs)])
ptSim_mah = mahalanobis(t(data_mx), 
                        center=colMeans(data_mx), 
                        cov(t(data_mx)), inverted = FALSE, tol=1e-50)
ggplot() + geom_point(aes(1:ncol(data_mx), ptSim_mah, colour=diags))




# Visualize main disease module for ZSD and RCDP
rm(list=ls())
require(R.utils)
load("/Users/lillian.rosa/Downloads/CTD/inst/shiny-app/disMod_July2020.RData")
# Selected disease module for ZSD
mets = disMod$zsd
ig = loadToEnv("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Clinical_paper/graphs_v8paper/bg_zsd_fold1.RData")[["ig_pruned"]]
ig = subgraph(ig, v=mets)
E(ig)$weight = abs(E(ig)$weight)*100
E(ig)$color = "#6a0dad"
coords = layout.fruchterman.reingold(ig)
png("ptSim/zsd-blowout_origZscore.png")
plot(ig, layout=coords, edge.width=E(ig)$weight)
dev.off()
V(ig)$name = rep("", length(V(ig)$name))
svg("ptSim/zsd-blowout_origZscore.svg")
plot(ig, layout=coords, edge.width=E(ig)$weight)
dev.off()


# Selected disease module for RCDP
mets = disMod$rcdp
ig = loadToEnv("/Users/lillian.rosa/OneDrive/MacFiles/9thCommitteeMeeting/Clinical_paper/graphs_v8paper/bg_rcdp_fold3.RData")[["ig_pruned"]]
ig = subgraph(ig, v=mets[which(mets %in% V(ig)$name)])
E(ig)$weight = abs(E(ig)$weight)*100
E(ig)$color = "#228B22"
coords = layout.fruchterman.reingold(ig)
png("ptSim/rcdp-blowout_origZscore.png")
plot(ig, layout=coords, edge.width=E(ig)$weight)
dev.off()
V(ig)$name = rep("", length(V(ig)$name))
svg("ptSim/rcdp-blowout_origZscore.svg")
plot(ig, layout=coords, edge.width=E(ig)$weight)
dev.off()

```

## Variant Reinterpretation
``` {r automated_reinterpretations}
rm(list=ls())
alaimo_wes = read.csv2("data/Alaimo_WES_data.txt", sep="\t", header=TRUE, stringsAsFactors = FALSE)
alaimo_wes$Category = trimws(alaimo_wes$Category)
alaimo_wes[grep("^1|^2|HGMD", alaimo_wes$Category), "Category"] = "Pathogenic"
alaimo_wes[grep("^3", alaimo_wes$Category), "Category"] = "Likely pathogenic"
alaimo_wes[which(alaimo_wes$Category=="4"), "Category"] = "Likely benign"
alaimo_wes[which(alaimo_wes$Category=="5"), "Category"] = "Benign"
alaimo_wes[which(alaimo_wes$Category=="6"), "Category"] = "VUS"
alaimo_wes[grep("^7", alaimo_wes$Category), "Category"] = "VUS"
#alaimo_wes = alaimo_wes[-which(alaimo_wes$Category %in% c("0", "8", "")), ]
table(alaimo_wes$Category)

disease_genes = list()
disease_genes[["abat"]] = "ABAT"
disease_genes[["arg"]] = "ARG1"
disease_genes[["asld"]] = "ASL"
disease_genes[["cit"]] = c("ASS1")
disease_genes[["mma"]] = c("MMAA", "MMAB", "MMADHC", "MCEE", "MUT")
disease_genes[["msud"]] = c("BCKDHA", "BCKDHB", "DBT")
disease_genes[["otc"]] = "OTC"
disease_genes[["pa"]] = c("PCCA", "PCCB")
disease_genes[["zsd"]] = c("PEX1", "PEX2", "PEX3", "PEX5", "PEX6", "PEX10", "PEX11B", "PEX12", "PEX13", "PEX14", "PEX16", "PEX19", "PEX26")
disease_genes[["rcdp"]] = c("PEX7", "GNPAT", "AGPS", "PEX5")
disease_genes[["pku"]] = "PAH"
disease_genes[["cob"]] = c("MMACHC", "MMADHC", "MTRR", "LMBRD1", "MTR", "ABCD4", "THAP11", "ZNF143", "HCFC1")
disease_genes[["ga"]] = c("GCDH", "ETFA", "ETFB", "ETFDH", "C7ORF10")
disease_genes[["gamt"]] = "GAMT"
disease_genes[["aadc"]] = "DDC"
disease_genes[["adsl"]] = "ADSL"


ind = c()
for (i in 1:nrow(alaimo_wes)) {
  ii = unlist(strsplit(alaimo_wes$Gene[i], split=","))
  if (any(ii %in% unlist(disease_genes))) {
    ind = c(ind, i)
  } else if (i=="") {
    ind = c(ind, i)
  }
}
alaimo_wes = alaimo_wes[ind,]
table(alaimo_wes$Gene)
table(alaimo_wes$Category)
ind = which(duplicated(alaimo_wes[,c(1:12)]))
if (length(ind)>0) {
  alaimo_wes = alaimo_wes[-ind,]
}
# Should be 45 MAPS patient samples from 40 unique WES patients, where selected patients had variants in >=1 of 49 disease genes in disease_genes
pt.ids = unique(alaimo_wes$DnaNumber)
wesIDs_tomaps = read.csv2("data/Alaimo_MAPSids.txt", sep="\t", header=TRUE)
wesIDs_tomaps = wesIDs_tomaps[which(wesIDs_tomaps$Lab.Number %in% pt.ids),]
dim(wesIDs_tomaps) 
length(unique(wesIDs_tomaps$Lab.Number))
length(unlist(disease_genes))

# Break UNK cases into Case 1-5 by disease gene.
require(ggplot2)
load("clinical_data_Oct2020.RData")
names(cohorts) = toupper(names(cohorts))
wesIDs_tomaps = read.csv2("data/Alaimo_MAPSids.txt", sep="\t", header=TRUE)
disease_genes2 = unlist(disease_genes)
pt.ids = unique(alaimo_wes$DnaNumber)
dff_reinterpret = data.frame(gene=character(), case1=character(), case2=character(), case3=character(), case4=character(), case5=character(), stringsAsFactors = FALSE)
for (g in 1:length(disease_genes2)) {
  print(sprintf("Genes %s...", disease_genes2[g]))
  pts_case1 = c()
  pts_case2 = c()
  pts_case3 = c()
  pts_case4 = c()
  pts_case5 = c()
  for (pt in 1:length(pt.ids)) {
    wes = alaimo_wes[which(alaimo_wes$DnaNumber==pt.ids[pt]), ]
    wes = wes[which(wes$Gene==disease_genes2[g]), ]
    ptID = wesIDs_tomaps[which(wesIDs_tomaps$Lab.Number==pt.ids[pt]), "Plasma.MAPS"]
    for (pp in ptID) {
      if (nrow(wes)==0) {
        pts_case5 = c(pts_case5, pp) # All benign
      } else {
        ind = grep("athogenic|VUS", wes$Category)
        if (length(ind)==0) { 
          pts_case5 = c(pts_case5, pp) # All benign
        } else {
          # Which are hom Pathogenic or het Pathogenic?
          hom_path = intersect(grep("athogenic", wes$Category), grep("Hom", wes$Zygosity))
          het_path = intersect(grep("athogenic", wes$Category), grep("Het", wes$Zygosity))
          hom_vus = intersect(grep("VUS|Uncertain|UNK", wes$Category), grep("Hom", wes$Zygosity))
          het_vus = intersect(grep("VUS|Uncertain|UNK", wes$Category), grep("Het", wes$Zygosity))
          if (length(hom_path)>0 || length(het_path)>1) { # homozygous pathogenic or compound heterozygote pathogenic
            pts_case1 = c(pts_case1, pp)
          }
          if (length(het_path)>0 && (length(hom_vus)>0 || length(het_vus)>0)) { # known carrier + at least 1 VUS
            pts_case2 = c(pts_case2, pp)
          }
          if (length(hom_vus)>0 || length(het_vus)>1) { # hom VUSs OR 2 het VUSs
            pts_case3 = c(pts_case3, pp)
          }
          if (length(het_vus)>0 || length(het_path)==1) {
            pts_case4 = c(pts_case4, pp) # known carrier with no VUSs, or potential carrier
          }
        }
      }
    }
  }
  if (length(which(pts_case5 %in% c(pts_case1, pts_case2, pts_case3, pts_case4)))>0) {
    pts_case5 = pts_case5[-which(pts_case5 %in% c(pts_case1, pts_case2, pts_case3, pts_case4))]
  }
  if (length(which(pts_case4 %in% c(pts_case1, pts_case2, pts_case3)))>0) {
    pts_case4 = pts_case4[-which(pts_case4 %in% c(pts_case1, pts_case2, pts_case3))]
  }
  if (length(which(pts_case3 %in% c(pts_case1, pts_case2)))>0) {
    pts_case3 = pts_case3[-which(pts_case3 %in% c(pts_case1, pts_case2))]
  }
  if (length(which(pts_case2 %in% c(pts_case1)))>0) {
    pts_case2 = pts_case2[-which(pts_case2 %in% c(pts_case1))]
  }
  print(pts_case3)
  dff_reinterpret[g, "gene"] = disease_genes2[g]
  dff_reinterpret[g, "case1"] = paste(pts_case1, sep=", ", collapse=", ")
  dff_reinterpret[g, "case2"] = paste(pts_case2, sep=", ", collapse=", ")
  dff_reinterpret[g, "case3"] = paste(pts_case3, sep=", ", collapse=", ")
  dff_reinterpret[g, "case4"] = paste(pts_case4, sep=", ", collapse=", ")
  dff_reinterpret[g, "case5"] = paste(pts_case5, sep=", ", collapse=", ")
}



# Now do the reinterpretations by disease state.
require(EmpiricalBrownsMethod)
names(cohorts) = tolower(names(cohorts))
for (model in c("aadc", "abat", "adsl", "arg", "asld", "otc", "cit", "cob", "ga", "gamt", "msud", "mma", "pa", "pku", "zsd", "rcdp")) {
  # Get all pts which have variants in the disease genes for given disease state, WES ids
  dis_pts = alaimo_wes[which(alaimo_wes$Gene %in% disease_genes[[model]]),"DnaNumber"]
  maps_ids = wesIDs_tomaps[which(wesIDs_tomaps$Lab.Number %in% dis_pts), "Plasma.MAPS"]
  
  if (length(maps_ids)>0) {
    print(sprintf("FOR MODEL %s...", toupper(model)))
    # For all dis_pts, get the CTD / CTDdisMod combined score. If < 0.05, this is a hit. Reinterpret variants in favor of pathogenic.
    # If < 0.15, this is a borderline hit. Should also report for future disease monitoring.
    load(sprintf("model/dd-%s-loocv-kmx30.RData", model))
    df_model2 = df_model
    df_model = df_model[which(df_model$ptID %in% sprintf("X%s", maps_ids)), ]
    df_model$bits = -log2(p.adjust(2^-df_model$bits, method="bonferroni"))
    ctd_pval = ifelse(2^-df_model[, "bits"]>1, 1, 2^-df_model[, "bits"])
    ctdDisMod_percentile = sapply(df_model[, "ctdDisMod"], function(i) length(which(df_model2$ctdDisMod<=i))/nrow(df_model2))
    combined_network = apply(cbind(ctd_pval, ctdDisMod_percentile), 1, function(i)  empiricalBrownsMethod(data_matrix = rbind(df_model2$bits, df_model2$ctdDisMod), p_values = i, TRUE)$P_test)
    names(ctd_pval) = df_model$ptID
    names(ctdDisMod_percentile) = df_model$ptID
    names(combined_network) = df_model$ptID
    
    # Hits: dis_pts with < 0.05
    pt_hits_network = names(combined_network[which(combined_network<=0.05)])
    pt_borderline_network = names(combined_network[which(combined_network<=0.15)])
    if (length(which(pt_borderline_network %in% pt_hits_network))>0) {
      pt_borderline_network = pt_borderline_network[-which(pt_borderline_network %in% pt_hits_network)]
    }
  
    pt_sig_wes = c(unlist(strsplit(dff_reinterpret[which(dff_reinterpret$gene %in% disease_genes[[model]]), "case1"], split=", ")),
                   unlist(strsplit(dff_reinterpret[which(dff_reinterpret$gene %in% disease_genes[[model]]), "case2"], split=", ")),
                   unlist(strsplit(dff_reinterpret[which(dff_reinterpret$gene %in% disease_genes[[model]]), "case3"], split=", ")))
    pt_sig_wes = sprintf("X%s", pt_sig_wes)
    ctd_pos_map = pt_hits_network[which(pt_hits_network %in% cohorts$maps)]
    print(sprintf("Alaimo patient HITS = %s", paste(ctd_pos_map[which(ctd_pos_map %in% pt_sig_wes)], sep=", ", collapse=", ")))
    ctd_border_map = pt_borderline_network[which(pt_borderline_network %in% cohorts$maps)]
    print(sprintf("Alaimo patient BORDERLINE HITS = %s", paste(ctd_border_map[which(ctd_border_map %in% pt_sig_wes)], sep=", ", collapse=", ")))
  
    # Were there any WES cases that should have (case1) or could have (case2, case3) been hits that weren't? 
    # Did manual inspection get these?
    fn_case1 = pt_sig_wes[which(!(pt_sig_wes %in% c(pt_hits_network, pt_borderline_network)))]
    print(sprintf("Missed wes cases = %s", paste(fn_case1, sep=", ", collapse=", ")))
    
    # Get CTD, CTDdisMod and Combined signal for all HITS
    print(format(ctd_pval[ctd_pos_map[which(ctd_pos_map %in% pt_sig_wes)]], digits=3))
    print(format(ctdDisMod_percentile[ctd_pos_map[which(ctd_pos_map %in% pt_sig_wes)]], digits=3))
    print(format(combined_network[ctd_pos_map[which(ctd_pos_map %in% pt_sig_wes)]], digit=3))

    # BORDERLINE HITS
    print(format(ctd_pval[ctd_border_map[which(ctd_border_map %in% pt_sig_wes)]], digit=3))
    print(format(ctdDisMod_percentile[ctd_border_map[which(ctd_border_map %in% pt_sig_wes)]], digit=3))
    print(format(combined_network[ctd_border_map[which(ctd_border_map %in% pt_sig_wes)]], digit=3))
  }
}


# Get rankings for HITS and BORDERLINE HITS
require(EmpiricalBrownsMethod)
#ptID = "X606789" # NOVEL
#ptID = "X606789"# "X602464", "X623239", "X697157", "X598510", "X595481", "X651374", "X618146", "X672307", "X706087", "X731982", "X763038", # REPRODUCED
for (ptID in c("X602464", "X623239", "X697157", "X598510", "X595481", "X651374", "X618146", "X672307", "X706087", "X731982", "X763038", "X606789")) {
  print(ptID)
  df_ranks = data.frame(diag=character(), combined=numeric(), stringsAsFactors = FALSE)
  r = 1
  for (model in c("aadc", "abat", "adsl", "arg", "asld", "otc", "cit", "cob", "ga", "gamt", "msud", "mma", "pa", "pku", "zsd", "rcdp")) {
    print(model)
    load(sprintf("model/dd-%s-loocv-kmx30.RData", model))
    df_model2 = df_model
    df_model$bits = -log2(p.adjust(2^-df_model$bits, method="bonferroni"))
    ctd_pval = ifelse(2^-df_model[, "bits"]>1, 1, 2^-df_model[, "bits"])
    ctdDisMod_percentile = sapply(df_model[, "ctdDisMod"], function(i) length(which(df_model$ctdDisMod<=i))/nrow(df_model))
    combined_network = apply(cbind(ctd_pval, ctdDisMod_percentile), 1, function(i)  empiricalBrownsMethod(data_matrix = rbind(df_model2$bits, df_model2$ctdDisMod), p_values = i, TRUE)$P_test)
    names(ctd_pval) = df_model$ptID
    names(ctdDisMod_percentile) = df_model$ptID
    names(combined_network) = df_model$ptID
    
    df_ranks[r, "diag"] = model
    df_ranks[r, "combined"] = combined_network[ptID]
    r = r + 1
  }
  print(df_ranks[order(df_ranks$combined, decreasing = FALSE),])
}





# Get the module that explains the patient HIT / BORDERLINE HIT
rm(list=ls())
load("clinical_data_July2020.RData")
kmx=30
for (model in c("aadc", "abat", "adsl", "arg", "asld", "cit", "otc", "cob", "ga", "gamt", "msud", "mma", "pa", "zsd", "rcdp", "pku")) {
  if (model=="pku") { p = which(colnames(data_mx)=="X623239") }
  if (model=="gamt") { p = which(colnames(data_mx)=="X697157") }
  if (model=="mma") { p = which(colnames(data_mx)=="X763038") }
  if (model=="cit") { p = which(colnames(data_mx)=="X731982") }
  if (model=="cob") { p = which(colnames(data_mx)=="X706087") } # X634552, X616411, X706087
  if (model=="zsd") { p = which(colnames(data_mx)=="X618146") } # X606789, X618146
  if (model=="aadc") { p = which(colnames(data_mx)=="X672307") } # X602464, X672307
  if (model=="abat") { p = which(colnames(data_mx)=="X651374") } # X598510, X595481, X651374
  
  ptID = colnames(data_mx)[p]
  print(sprintf("Patient %s, %d/%d...", ptID, p, ncol(data_mx)))
    
  mets = c()
  bits = c()
  for (fold in 1:length(cohorts[[model]])) {
    load("clinical_data_July2020.RData")
    ig = loadToEnv(sprintf("graphs_v8paper/bg_%s_fold%d.RData", model, fold))[["ig_pruned"]]
    ranks = loadToEnv(sprintf("ranks_v8paper/%s%d-ranks.RData", model, fold))[["permutationByStartNode"]]
    ranks = lapply(ranks, tolower)
    adjacency_matrix = list(as.matrix(get.adjacency(ig, attr="weight")))
    G = vector(mode="list", length=length(V(ig)$name))
    names(G) = V(ig)$name
    data_mx = data_mx[which(rownames(data_mx) %in% V(ig)$name), ]
    data_mx = data_mx[,which(colnames(data_mx) %in% unlist(cohorts))]
    S = data_mx[order(abs(data_mx[,ptID]), decreasing = TRUE),ptID][1:kmx]
    ptBSbyK = singleNode.getPtBSbyK(names(S), ranks)
    res = mle.getEncodingLength(ptBSbyK, NULL, ptID, G)
    mets = c(mets, names(S[names(which(ptBSbyK[[which.max(res$d.score)]]==1))]))
    bits = c(bits, res[which.max(res$d.score), "d.score"])
  }
  S = data_mx[order(abs(data_mx[,ptID]), decreasing = TRUE),ptID]
  print(paste(sprintf("%s (%.3f)", names(S[names(table(mets)[which(table(mets)>length(cohorts[[model]])/3)])]), S[names(table(mets)[which(table(mets)>length(cohorts[[model]])/3)])]), sep=", ", collapse = ", "))
  
  #ss = names(S[names(table(mets)[which(table(mets)>length(cohorts[[model]])/3)])])
  #ptBSbyK = singleNode.getPtBSbyK(ss, ranks)
  #res = mle.getEncodingLength(ptBSbyK, NULL, ptID, G)
  #ee = induced_subgraph(ig, v=names(ptBSbyK[[which.max(res$d.score)]]))
  #E(ee)$weight = 50*abs(E(ee)$weight)
  #plot(ee)
}


```